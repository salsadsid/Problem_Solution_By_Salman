এই সমস্যার মূল ধারণা হলো, একটি অ্যারে থেকে ধারাবাহিক (contiguous) অংশ বা সাবঅ্যারেগুলোর মধ্যে এমন একটি অংশ খুঁজে বের করা, যার দৈর্ঘ্য `k` এবং যেটির যোগফল সর্বোচ্চ।

এটি সমাধান করার জন্য আমরা **স্লাইডিং উইন্ডো** পদ্ধতি ব্যবহার করেছি, যা কার্যকরী এবং দ্রুত।

### পদ্ধতি:

১. প্রথমে অ্যারের প্রথম `k` সংখ্যার যোগফল বের করা হয়।
২. এরপর, উইন্ডোটি এক ধাপ করে সামনের দিকে সরানো হয় এবং প্রতিবার নতুন একটি সংখ্যা উইন্ডোতে যোগ করে, আগের উইন্ডোর প্রথম সংখ্যাটি বাদ দেওয়া হয়।
৩. প্রতিটি উইন্ডোতে, সর্বোচ্চ যোগফলটি সংরক্ষণ করা হয়।
৪. এইভাবে আমরা পুরো অ্যারেটি একবার স্ক্যান করে প্রতিটি সম্ভাব্য উইন্ডোর সর্বোচ্চ যোগফল বের করি।

এই পদ্ধতিটি দ্রুততার সাথে কাজ করে কারণ আমরা প্রতিটি সংখ্যা একবারই যোগ-বিয়োগ করি, এবং অ্যারের প্রতিটি উপাদান শুধুমাত্র একবার প্রসেস করা হয়।

### উদাহরণ:

- অ্যারেতে `k=2` এবং `[100, 200, 300, 400]` থাকলে:
  - প্রথম উইন্ডো `[100, 200]`, যোগফল ৩০০।
  - দ্বিতীয় উইন্ডো `[200, 300]`, যোগফল ৫০০।
  - তৃতীয় উইন্ডো `[300, 400]`, যোগফল ৭০০ (এটি সর্বোচ্চ)।

### সমাধানের কোড:

```cpp
class Solution {
  public:
    long long maximumSumSubarray(vector<int>& arr, int k) {
        int n = arr.size();
        int l = 0, r = 0;
        long long ans = 0, sum = 0;

        // Sliding window technique
        while (r < n) {
            sum += arr[r];

            if (r - l + 1 == k) {
                ans = max(ans, sum);  // Update maximum sum
                sum -= arr[l];  // Slide the window by removing the first element
                l++;  // Move the left pointer
            }
            r++;  // Move the right pointer
        }

        return ans;  // Return the maximum sum found
    }
};
```

### সহজ ভাষায় ব্যাখ্যা:

আমরা প্রতিটি উইন্ডোর যোগফল গণনা করে তা `ans` এ সংরক্ষণ করছি, এবং যদি নতুন কোনো উইন্ডোর যোগফল আগের চেয়ে বেশি হয়, তাহলে সেটিকে সর্বোচ্চ হিসেবে ধরে নিচ্ছি। উইন্ডোটি প্রতিবার সামনের দিকে একটি করে সংখ্যা নিয়ে এগিয়ে যাচ্ছে, এবং পুরনো সংখ্যাগুলো বাদ দেওয়া হচ্ছে।
